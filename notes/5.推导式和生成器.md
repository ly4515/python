## 推导式

列表推导式

```python
list = [1, 2, 3, 4]
# [表达式 for 变量 in 列表]
list1 = [x+2 for x in list]

# [表达式 for 变量 in 列表 if 条件]
list2 = [x+2 for x in list if x % 2 == 0]

# [表达式A if 条件 else 表达式B for 变量 in 列表]
list3 = [x+2 if x % 2 == 0 else x+1 for x in list]
```

集合推导式：{表达式  for  变量  in  集合}     类似列表推导式，但没有重复元素

字典推导式：{key,  value   for  k, y in  字典.items()}

```python
dict = {'a': 'A', 'b': 'B', 'c': 'C', 'd': 'C'}
new_dict = {value: key for key, value in dict.items()}
print(new_dict)            # 键唯一

# {'A': 'a', 'B': 'b', 'C': 'd'}
```

## 迭代器

迭代是访问集合元素的一种方式，迭代器是一个可以记住遍历位置的对象

迭代器对象从集合的第一个元素开始访问，知道左右元素被访问完结束

迭代器只能往前不会后退

可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator



可迭代的不一定就是迭代器

生成器是可迭代的，也是迭代器

list是可迭代的，但不是迭代器

list--------->iter(list)---------->迭代器 next()

```python
list = [1, 2, 3, 4]
print(type(list))
new_list = iter(list)
print(type(new_list))

# <class 'list'>
# <class 'list_iterator'>
```



## 生成器

一边循环一边计算的机制，称为生成器（generator），利用生成器不必创建完整的list，从而节省大量的空间

```python
# 把一个列表生成式的[]改成()，就创建了一个generator：
g = (x*3 for x in range(20))
print(type(g))   # <class 'generator'>
print(g)         # <generator object <genexpr> at 0x000002756F186AC8>

# 通过调用__next__()得到元素
print(g.__next__())
print(g.__next__())

# next()
print(next(g))
print(next(g))
```

用循环产生生成器，会产生死循环，可以结合异常处理

```python
g = (x*3 for x in range(10))
while True:
    try:
        e = next(g)
        print(e)
    except:
        print('没有更多元素了')
        break
```



1. 定义一个函数，函数中使用yield关键字
2. 调用函数，接收调用的结果
3. 得到的结果就是生成器

```python
# 只要函数中出现了yield关键字，函数就变成生成器了
def func():      
    n = 0
    while True:
        n += 1
        yield n  

a = func()
print(next(a))
print(next(a))
print(a.__next__())
```

